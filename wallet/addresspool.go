/*
 * Copyright (c) 2013-2015 The btcsuite developers
 * Copyright (c) 2015 The Decred developers
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package wallet

import (
	"sync"

	"github.com/decred/dcrutil"
	"github.com/decred/dcrwallet/waddrmgr"
)

// addressPoolBuffer is the number of addresses to fetch when the address pool
// runs out of new addresses to use.
const addressPoolBuffer = 20

// addressPool is a cache of addresses to use that are generated by the
// address manager. It is safe than directly calling the address manager
// because doing that will increment the cursor of the extended key even
// if the created transaction errors out in some way.
type addressPool struct {
	// Represent addresses as strings because the address interface
	// doesn't have any good way to make comparisons.
	addresses []string
	cursor    int
	branch    uint32
	mutex     *sync.Mutex
	wallet    *Wallet
}

// initialize initializes an address pool for usage by loading the latest
// unused address from the blockchain itself.
func (a *addressPool) initialize(branch uint32, w *Wallet) error {
	a.addresses = make([]string, 0)
	a.mutex = new(sync.Mutex)
	a.wallet = w
	a.branch = branch

	var err error

	// Retrieve the last addresses from wallet closing and storing.
	lastExtAddr, lastIntAddr, err := w.Manager.LastUsedAddresses()
	if err != nil {
		return err
	}
	var lastSavedAddr dcrutil.Address

	// Get the last managed address for the account and branch.
	var lastIndex uint32
	if branch == waddrmgr.InternalBranch {
		_, lastIndex, err =
			a.wallet.Manager.LastInternalAddress(waddrmgr.DefaultAccountNum)
		if err != nil {
			return err
		}
		lastSavedAddr = lastIntAddr
	}
	if branch == waddrmgr.ExternalBranch {
		_, lastIndex, err =
			a.wallet.Manager.LastExternalAddress(waddrmgr.DefaultAccountNum)
		if err != nil {
			return err
		}
		lastSavedAddr = lastExtAddr
	}

	// Get the actual last index as recorded in the blockchain.
	traversed := 0
	actualLastIndex := lastIndex
	for actualLastIndex != 0 && traversed != addressPoolBuffer {
		addr, err := a.wallet.Manager.GetAddress(actualLastIndex,
			waddrmgr.DefaultAccountNum, branch)
		if err != nil {
			return err
		}

		// Start with the address on tip if address reuse is disabled.
		if !w.addressReuse || w.ChainClient() == nil {
			// If address reuse is disabled, we compare to the last
			// stored address.
			if lastSavedAddr != nil {
				lsaH160 := lastSavedAddr.Hash160()
				thisH160 := addr.Hash160()
				if *lsaH160 == *thisH160 {
					// We actually append this address because the
					// LastUsedAddresses function in Manager actually
					// stores the next to-be-used address rather than
					// the last used address. See Close below.
					a.addresses = append([]string{addr.EncodeAddress()},
						a.addresses...)
					break
				}
			}
		} else {
			// Otherwise, search the blockchain for the last actually used
			// address.
			exists, err := a.wallet.existsAddressOnChain(addr)
			if err != nil {
				return err
			}
			if exists {
				break
			}
		}

		// Insert this unused address into the cache.
		a.addresses = append([]string{addr.EncodeAddress()},
			a.addresses...)

		actualLastIndex--
		traversed++
	}

	a.cursor = 0

	return nil
}

// GetNewAddress must be run as many times as necessary with the address pool
// mutex locked. Each time, it returns a single new address while adding that
// address to the toDelete map. If the address pool runs out of addresses, it
// generates more from the address manager.
func (a *addressPool) GetNewAddress() (dcrutil.Address, error) {
	chainClient, err := a.wallet.requireChainClient()
	if err != nil {
		return nil, err
	}

	// Replenish the pool if we're at the last address.
	if a.cursor == len(a.addresses)-1 || len(a.addresses) == 0 {
		if a.branch == waddrmgr.InternalBranch {
			addrs, err :=
				a.wallet.Manager.NextInternalAddresses(
					waddrmgr.DefaultAccountNum, addressPoolBuffer)
			if err != nil {
				return nil, err
			}

			for _, addr := range addrs {
				a.addresses = append(a.addresses, addr.Address().EncodeAddress())
			}
		}

		if a.branch == waddrmgr.ExternalBranch {
			addrs, err :=
				a.wallet.Manager.NextExternalAddresses(
					waddrmgr.DefaultAccountNum, addressPoolBuffer)
			if err != nil {
				return nil, err
			}

			for _, addr := range addrs {
				a.addresses = append(a.addresses, addr.Address().EncodeAddress())
			}
		}
	}

	// As these are all encoded addresses, we should never throw an error
	// converting back.
	curAddressStr := a.addresses[a.cursor]
	curAddress, _ := dcrutil.DecodeAddress(curAddressStr, a.wallet.chainParams)
	a.cursor++

	// Add the address to the notifications watcher.
	addrs := make([]dcrutil.Address, 1)
	addrs[0] = curAddress
	if err := chainClient.NotifyReceived(addrs); err != nil {
		return nil, err
	}

	return curAddress, nil
}

// BatchFinish must be run after every successful series of usages of
// GetNewAddress to purge the addresses from the unused map.
func (a *addressPool) BatchFinish() {
	if a.cursor >= len(a.addresses) {
		a.addresses = nil
		a.cursor = 0
		return
	}

	a.addresses = a.addresses[a.cursor:len(a.addresses)]
	a.cursor = 0
}

// BatchRollback must be run after every unsuccessful series of usages
// of GetNewAddress to restore the cursor to the original position in
// the slice, thus marking all addresses unused again.
func (a *addressPool) BatchRollback() {
	a.cursor = 0
}

// CloseAddressPools grabs one last new address for both internal and external
// acounts. Then it inserts them into the address manager database, so that
// the address manager can be used upon startup to restore the cursor position
// in the address pool.
func (w *Wallet) CloseAddressPools() {
	if w.internalPool == nil {
		return
	}
	if w.externalPool == nil {
		return
	}
	if w.internalPool.mutex == nil {
		return
	}
	if w.externalPool.mutex == nil {
		return
	}

	w.internalPool.mutex.Lock()
	w.externalPool.mutex.Lock()
	defer w.internalPool.mutex.Unlock()
	defer w.externalPool.mutex.Unlock()

	lastExtAddr, err := w.externalPool.GetNewAddress()
	if err != nil {
		log.Errorf("Failed to get last used address for address "+
			"pool external: %v", err.Error())
		return
	}
	lastIntAddr, err := w.internalPool.GetNewAddress()
	if err != nil {
		log.Errorf("Failed to get last used address for address "+
			"pool internal: %v", err.Error())
		return
	}

	err = w.Manager.StoreLastUsedAddresses(lastExtAddr, lastIntAddr)
	if err != nil {
		log.Errorf("Failed to store last used addresses for address "+
			"pools in the manager: %v", err.Error())
	}
	return
}

// GetNewAddressExternal is the exported function that gets a new external address
// for the default account from the external address mempool.
func (w *Wallet) GetNewAddressExternal() (dcrutil.Address, error) {
	w.externalPool.mutex.Lock()
	defer w.externalPool.mutex.Unlock()
	return w.externalPool.GetNewAddress()
}

// GetNewAddressExternal is the exported function that gets a new internal address
// for the default account from the internal address mempool.
func (w *Wallet) GetNewAddressInternal() (dcrutil.Address, error) {
	w.internalPool.mutex.Lock()
	defer w.internalPool.mutex.Unlock()
	return w.internalPool.GetNewAddress()
}
